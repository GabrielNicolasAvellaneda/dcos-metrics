package main

import (
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"os"
)

var (
	varnameFlag = flag.String("varname", "", "Name of var in generated file")
	infileFlag = flag.String("infile", "", "Path to input JSON schema")
	outfileFlag = flag.String("outfile", "", "Path to output go file")
	outputHeader = `package collector

// THIS FILE IS AUTOGENERATED BY 'go generate'. DO NOT EDIT.

`
	outputVarFormat = "var %s = `%s`"
	outputFooter = `

// AGAIN, THIS FILE IS AUTOGENERATED BY 'go generate'. DO NOT EDIT.`
)

func main() {
	flag.Usage = func() {
		fmt.Fprint(os.Stderr,
			"Generates Go source file with a named var containing an Avro JSON schema\n")
		fmt.Fprintf(os.Stderr, "Usage of %s:\n", os.Args[0])
		flag.PrintDefaults()
	}
	flag.Parse()

	if *infileFlag == "" {
		flag.Usage()
		log.Fatalf("Missing argument: -infile")
	}
	infile, err := os.Open(*infileFlag)
	if err != nil {
		log.Fatalf("Couldn't open input %s: %s", infileFlag, err)
	}
	data, err := ioutil.ReadAll(infile)
	if err != nil {
		log.Fatalf("Failed to read from %s: %s", infileFlag, err)
	}

	// goavro doesn't support a list of schema entries, so we need to perform our own nesting

	if *outfileFlag == "" {
		flag.Usage()
		log.Fatalf("Missing argument: -outfile")
	}
	if *varnameFlag == "" {
		flag.Usage()
		log.Fatalf("Missing argument: -varname")
	}
	outfile, err := os.Create(*outfileFlag)
	if err != nil {
		log.Fatalf("Couldn't open output %s: %s", outfileFlag, err)
	}
	_, err = fmt.Fprint(outfile, outputHeader)
	if err != nil {
		log.Fatalf("Couldn't write header to %s: %s", outfileFlag, err)
	}
	_, err = fmt.Fprintf(outfile, outputVarFormat, *varnameFlag, data)
	if err != nil {
		log.Fatalf("Couldn't write var to %s: %s", outfileFlag, err)
	}
	_, err = fmt.Fprint(outfile, outputFooter)
	if err != nil {
		log.Fatalf("Couldn't write footer to %s: %s", outfileFlag, err)
	}
}
